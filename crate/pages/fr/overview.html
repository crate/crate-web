title: Vue d'ensemble
description: Crate est un datastore comportant les avantages d’une base de données orientée documents NoSQL, et intégrant une fonction de recherche puissante (Elasticsearch inclut en tant que bibliothèque), accessible en utilisant SQL.

{% extends "base.html" %}

{% block header %}
<div class="wrapper wrapper-hero" id="wrapper-hero-overview">
  <div class="container">
    <h1>Crate: un datastore SQL en temps réel facilement ajustable</h1>
  </div>
</div>
{% endblock %}

{% block body %}
<div class="wrapper wrapper-border">
<div class="container">
  <div class="row">
    <div class="col-sm-12">
      <h2>Ajustable. Simple. Rapide.</h2>
      <p><strong>Crate est une grappe de datastores shared-nothing, intégralement interrogeables et orientés document : un backend rapide, puissant et massivement ajustable pour les applis à forte consommation de données, l’internet des objets ou les analytiques en temps réel. Cette solution est intégralement open source.</strong></p>
      <p><strong>Crate est un datastore comportant les avantages d’une base de données orientée documents NoSQL, et intégrant une fonction de recherche puissante (Elasticsearch inclut en tant que bibliothèque), accessible en utilisant SQL.</strong></p>
    </div>
  </div>
</div>
</div>

<div class="wrapper wrapper-bg-gray">
<div class="container">
  <div class="row">
    <div class="col-sm-12">

      <h2>Puissant et ultra rapide</h2>
      <p>Crate.IO est un backend puissant pour les données tabulaires, les dossiers semi-structurés et les objets binaires (blobs). Il offre une disponibilité élevée ainsi qu’un accès massivement parallèle en temps réel, permettant d’obtenir des temps de réponse inférieurs à la seconde sur des milliards de dossiers.</p>
      <h2>Aucune administration</h2>
      <p>Tous les nœuds de Crate sont égaux. Ajouter des nœuds sur du matériel courant ou sur le nuage est aussi simple qu’entrer une seule ligne de commande sur votre terminal. Une grappe Crate.IO est à la fois capable de s’auto-configurer et de s’auto-réparer.</p>
      <h2>Pourquoi Crate ?</h2>
      <p>Crate est une solution en temps réel ajustable, qui offre d’énormes avantages économiques et fonctionnels. Crate.IO a adopté une position unique en combinant le modèle relationnel SQL (c.-à-d. MySQL), le modèle NoSQL (c.-à-d. MongoDB) et la recherche (Lucene/ES).</p>

    </div>
  </div>
</div>
</div>

<div class="wrapper wrapper-border">
<div class="container">
  <div class="row">
    <div class="col-sm-6">
      <img class="img-responsive thumbnail" src="{% media '/media/1502/crate-architecture.png' %}" />
    </div>
    <div class="col-sm-6">

      <h2>MASSIVEMENT PARALLÈLE EN TEMPS RÉEL</h2>
      <h3>RAPIDE ET FACILE À UTILISER</h3>
      <p>Utilise SQL pour des lectures et écritures dans des délais inférieurs à la seconde.</p>
      <h3>DISPONIBILITÉ ÉLEVÉE</h3>
      <p>Les grappes Crate sont persistantes et résistantes. Les nœuds en défaut sont supprimés, et de nouveaux nœuds sont ajoutés.</p>

    </div>
  </div>
</div>
</div>

<div class="wrapper wrapper-bg-gray">
<div class="container">
  <div class="row">
    <div class="col-sm-12">

      <h2>CRATE VS UN MÉLANGE DE TECHNOLOGIES</h2>
      <p>La solution Crate.IO a été bâtie de manière à ce que les développeurs dont le backend consomme beaucoup de données n’aient pas besoin « d’empiler » plusieurs technologies pour pouvoir stocker les documents et les blobs en plus de prendre en charge la recherche en temps réel. Nous voulions aussi éviter aux développeurs tout le travail manuel qu’impliquent le paramétrage, le sharding, la réplication et toutes les autres opérations rendues nécessaires pour maintenir en état un datastore dénormalisé volumineux. Nous avons privilégié un datastore simple, tolérant aux pannes et massivement ajustable qui peut être utilisé par n’importe qui sur une seule machine, sur plusieurs machines ou sur le nuage.<br />
        Un datastore pensé à destination des applis à forte consommation de données doit être persistant, ajustable horizontalement et capable de répondre aux cinq exigences suivantes :<br />
        (1) stocker les documents, (2) et les blobs, (3) retrouver ceux-ci (4) exécuter les interrogations (analytique) et (5) permettre de modifier directement la structure des données, le cas échéant.</p>
      <p>Les développeurs ne peuvent-ils pas se contenter d’empiler plusieurs technologies pour obtenir les mêmes résultats ? Voici quelques exemples :</p>
      <ul>
        <li>MongoDB + ElasticSearch + GridFS. GridFS permet le stockage de blobs, ElasticSearch permet la recherche et MongoDB se charge du reste. Modifier la structure des données peut s’avérer complexe, et gérer l’ajustement et les environnements multi-nœuds s’annonce difficile.</li>
        <li>Riak + Solr + Rados. Rados pour le stockage de blobs, Solr pour la recherche et Riak pour le reste. C’est une option très similaire à la précédente, qui présente à peu près les mêmes problèmes.</li>
        <li>CouchDb (stockage de documents et analytique) + ElasticSearch (recherche) + HDFS (stockage de blobs, archivage) + Hadoop (analytique et modifications). Cette solution présenterait les nombreux problèmes liés à Hadoop et à son aptitude à gérer les lourdes tâches d’écriture et de lecture.</li>
      </ul>
      <p>Voyons comment Crate répond à ces 5 exigences, tout en permettant aussi au datastore de s’auto-configurer et de s’auto-réparer.</p>
      <p>1. <strong>Stockage des documents</strong><br />
        Crate.IO stocke les documents par le biais des fonctionnalités incorporées de Lucene et d’ElasticSearch. Crate ajoute en plus une fonctionnalité de suppression/restauration pour les mises à niveau de version importantes, permettant ainsi d’atteindre un tout nouveau niveau de restauration temporelle.<br />
        2. <strong>Stockage de blobs</strong><br />
        Le stockage de blobs se fait en toute transparence, en utilisant l’implémentation de blobs de Crate, qui s’appuie sur la sémantique de grappe d’Elasticsearch pour la distribution, la réplication et l’allocation. Les blobs sont simplement et directement stockés sur le système de fichiers dans l’espace utilisateur.<br />
        3. <strong>Recherche des documents</strong><br />
        Crate utilise Elasticsearch pour la recherche – c’est tout simplement ce qui se fait de mieux en terme de vitesse.<br />
        4. <strong>Analytique de données en temps réel utilisant SQL</strong><br />
        Crate permet des analytiques de données en temps réel utilisant SQL par le biais de l’analyseur, planificateur et moteur d’exécution d’interrogations distribué. Celui-ci ajoute une fonctionnalité de groupage et de triage avancée afin d’offrir des fonctions similaires au « group by … having .. » et « order by » de SQL. Pensez Map/Reduce, mais en temps réel.<br />
        5. <strong>Effectuer des modifications sans avoir à tout refaire</strong><br />
        Vous vous souvenez de cette époque formidable où restructurer l’intégralité d’une base de données relationnelle était possible grâce à un seul script SQL ? Crate implémente cette fonctionnalité en empruntant la faculté de placer le résultat d’une interrogation directement dans un ou plusieurs indexes. Cette exigence prend encore plus d’importance pour les bases de données basées sur documents, dans lesquelles les données sont souvent stockées sous un format hautement dénormalisé.</p>
      </div>
    </div>
  </div>
</div>
</div>

<div class="wrapper wrapper-border">
<div class="container">
  <div class="row">
    <div class="col-sm-12"
      <h2>Configurations requises</h2>
      <p>Linux, Mac OS X ou Windows<br />
        Java 7<br />
        Python<br />
        (pour le client en ligne de commande)</p>
      <h2>Clients et outils</h2>
      <p>Crate Data est fourni avec une interface d’administration incorporée. L’interface en ligne de commande (Crate Shell – CraSh) permet des interrogations interactives. Le client Python de Crate est le plus avancé disponible et inclut l’intégration à SQLAlchemy.</p>
      <p><a class="btn btn-primary" href="{% url '/docs.html' %}">Téléchargez Crate</a></p>
    </div>
  </div>
</div>
</div>

{% endblock %}
